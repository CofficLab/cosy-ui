# 步骤 02.2：服务容器实现

## 目标
实现服务容器的核心功能，包括服务注册、解析和依赖注入。

## 任务清单
- [ ] 实现服务容器类
- [ ] 实现依赖注入
- [ ] 实现服务解析
- [ ] 实现生命周期管理

## 执行步骤

### 1. 创建服务容器类

**创建文件**: `src/container/container.ts`

```typescript
import { 
  ContainerInterface,
  ServiceProvider,
  Token,
  Constructor,
  Factory,
  ServiceDefinition,
  ServiceNotFoundError,
  CircularDependencyError
} from '../types'

export class Container implements ContainerInterface {
  private services = new Map<Token, ServiceDefinition>()
  private instances = new Map<Token, any>()
  private providers: ServiceProvider[] = []
  private booted = false

  // 服务绑定
  bind<T>(token: Token, implementation: Constructor<T>): this {
    return this.register(token, implementation, false)
  }

  singleton<T>(token: Token, implementation: Constructor<T>): this {
    return this.register(token, implementation, true)
  }

  factory<T>(token: Token, factory: Factory<T>): this {
    this.services.set(token, {
      token,
      factory,
      singleton: false
    })
    return this
  }

  // 服务解析
  resolve<T>(token: Token): T {
    return this.resolveService(token, [])
  }

  resolveAll<T>(tokens: Token[]): T[] {
    return tokens.map(token => this.resolve<T>(token))
  }

  // 服务管理
  has(token: Token): boolean {
    return this.services.has(token)
  }

  remove(token: Token): boolean {
    this.instances.delete(token)
    return this.services.delete(token)
  }

  clear(): void {
    this.services.clear()
    this.instances.clear()
    this.providers = []
    this.booted = false
  }

  // 服务提供者
  register(provider: ServiceProvider): this {
    this.providers.push(provider)
    provider.register(this)
    return this
  }

  async boot(): Promise<void> {
    if (this.booted) return

    for (const provider of this.providers) {
      if (provider.boot) {
        await provider.boot()
      }
    }

    this.booted = true
  }

  async shutdown(): Promise<void> {
    if (!this.booted) return

    for (const provider of [...this.providers].reverse()) {
      if (provider.shutdown) {
        await provider.shutdown()
      }
    }

    this.clear()
  }

  // 私有方法
  private register<T>(token: Token, implementation: Constructor<T>, singleton: boolean): this {
    const factory = (...args: any[]) => new implementation(...args)
    
    this.services.set(token, {
      token,
      factory,
      singleton,
      dependencies: this.getDependencies(implementation)
    })

    return this
  }

  private resolveService<T>(token: Token, stack: Token[]): T {
    // 检查循环依赖
    if (stack.includes(token)) {
      throw new CircularDependencyError([...stack, token])
    }

    // 获取服务定义
    const definition = this.services.get(token)
    if (!definition) {
      throw new ServiceNotFoundError(token)
    }

    // 检查单例实例
    if (definition.singleton && this.instances.has(token)) {
      return this.instances.get(token)
    }

    // 解析依赖
    const dependencies = (definition.dependencies || []).map(dep => 
      this.resolveService(dep, [...stack, token])
    )

    // 创建实例
    const instance = definition.factory(...dependencies)

    // 保存单例
    if (definition.singleton) {
      this.instances.set(token, instance)
    }

    return instance
  }

  private getDependencies(implementation: Constructor): Token[] {
    // 这里需要使用装饰器元数据来获取依赖
    // 具体实现将在装饰器部分完成
    return []
  }
}
```

### 2. 更新模块导出

**更新文件**: `src/container/index.ts`

```typescript
export { Container } from './container'
export { ServiceProvider } from './provider'
export { Inject, Injectable } from './decorators'

export type {
  ContainerInterface,
  ServiceDefinition,
  Token,
  Factory
} from '../types'
```

## 实现说明

### 服务注册
- `bind`: 注册瞬态服务
- `singleton`: 注册单例服务
- `factory`: 注册工厂函数

### 服务解析
- `resolve`: 解析单个服务
- `resolveAll`: 解析多个服务
- 支持循环依赖检测

### 生命周期管理
- `boot`: 启动所有服务提供者
- `shutdown`: 关闭所有服务提供者
- `clear`: 清理所有服务和实例

### 依赖注入
- 通过装饰器元数据获取依赖
- 自动解析构造函数参数
- 支持可选依赖

## 完成标志
- [ ] 服务容器功能完整
- [ ] 依赖注入正常工作
- [ ] 生命周期管理正确
- [ ] TypeScript 类型检查无错误

## 下一步
完成此步骤后，继续执行 `02.3-decorators.md`。 
