# 附件 02.1：服务容器详解

> 本文档是步骤 02 的补充材料，深入讲解服务容器（Service Container）的核心概念和在 Cosy Framework 中的重要作用。
> 
> **文件命名规则**: 
> - 主步骤：`01-xxx.md`、`02-xxx.md`、...
> - 附件文档：`01.1-xxx.md`、`01.2-xxx.md`、`02.1-xxx.md`、...

## 📚 目录
- [什么是服务容器](#什么是服务容器)
- [为什么需要依赖注入](#为什么需要依赖注入)
- [核心概念详解](#核心概念详解)
- [装饰器系统](#装饰器系统)
- [生命周期管理](#生命周期管理)
- [服务提供者模式](#服务提供者模式)
- [实际代码演示](#实际代码演示)
- [常见问题解答](#常见问题解答)

## 🎯 可运行演示

我们在 `examples/` 目录中提供了三个演示文件：

1. **[service-container-tutorial.md](../examples/service-container-tutorial.md)** - 理论基础和概念讲解
2. **[service-container-simple.ts](../examples/service-container-simple.ts)** - 简化版演示，专注于核心概念
3. **[service-container-demo.ts](../examples/service-container-demo.ts)** - 完整版演示，包含高级特性

运行演示：
```bash
cd packages/cosy-framework-docs
npx tsx examples/service-container-simple.ts
```

## 什么是服务容器

服务容器（Service Container）是一个 **依赖注入容器**，它是现代框架架构的核心组件。简单来说，它是一个智能的"对象工厂"，负责：

### 核心职责

```typescript
// 传统方式：手动创建和管理依赖
class UserController {
  private userService: UserService;
  private logger: Logger;

  constructor() {
    // 硬编码依赖，难以测试和维护
    this.logger = new ConsoleLogger();
    this.userService = new UserService(
      new DatabaseRepository(),
      this.logger
    );
  }
}

// 服务容器方式：自动管理依赖
@Injectable
class UserController {
  constructor(
    @Inject('UserService') private userService: UserService,
    @Inject('Logger') private logger: Logger
  ) {
    // 依赖由容器自动注入，清晰简洁
  }
}
```

## 为什么需要依赖注入

### 1. 解决紧耦合问题

**问题**：传统编程中，对象直接创建其依赖，导致紧耦合：

```typescript
// ❌ 紧耦合的代码
class EmailService {
  private transport = new SMTPTransport(); // 硬编码传输方式

  send(email: Email) {
    return this.transport.send(email);
  }
}

class UserService {
  private emailService = new EmailService(); // 硬编码邮件服务

  async register(userData: UserData) {
    const user = await this.createUser(userData);
    await this.emailService.send(welcomeEmail);
    return user;
  }
}
```

**解决方案**：依赖注入实现松耦合：

```typescript
// ✅ 松耦合的代码
interface EmailTransport {
  send(email: Email): Promise<void>;
}

@Injectable
class EmailService {
  constructor(
    @Inject('EmailTransport') private transport: EmailTransport
  ) {}

  send(email: Email) {
    return this.transport.send(email);
  }
}

@Injectable
class UserService {
  constructor(
    @Inject('EmailService') private emailService: EmailService
  ) {}

  async register(userData: UserData) {
    const user = await this.createUser(userData);
    await this.emailService.send(welcomeEmail);
    return user;
  }
}
```

### 2. 提升可测试性

```typescript
// 测试变得简单
describe('UserService', () => {
  it('should send welcome email', async () => {
    const mockEmailService = {
      send: jest.fn().mockResolvedValue(undefined)
    };

    const container = new ServiceContainer();
    container.instance('EmailService', mockEmailService);
    container.bind('UserService', UserService);

    const userService = container.resolve<UserService>('UserService');
    await userService.register(userData);

    expect(mockEmailService.send).toHaveBeenCalledWith(welcomeEmail);
  });
});
```

## 核心概念详解

### 1. 服务绑定（Service Binding）

服务绑定是将抽象标识符与具体实现关联的过程：

```typescript
// 基础绑定
container.bind('Logger', ConsoleLogger);

// 单例绑定
container.singleton('Database', DatabaseConnection);

// 实例绑定
container.instance('Config', configuration);

// 接口绑定
container.bind<IEmailService>('EmailService', SMTPEmailService);
```

### 2. 服务解析（Service Resolution）

容器根据标识符返回对应的服务实例：

```typescript
// 解析服务
const logger = container.resolve<Logger>('Logger');

// 自动依赖注入
const userService = container.resolve<UserService>('UserService');
// 容器会自动解析 UserService 的所有依赖
```

### 3. 依赖图（Dependency Graph）

容器会自动构建和解析复杂的依赖关系：

```typescript
// 复杂的依赖链
@Injectable
class UserController {
  constructor(
    @Inject('UserService') private userService: UserService,
    @Inject('Logger') private logger: Logger
  ) {}
}

@Injectable
class UserService {
  constructor(
    @Inject('UserRepository') private userRepo: UserRepository,
    @Inject('EmailService') private emailService: EmailService
  ) {}
}

@Injectable
class UserRepository {
  constructor(
    @Inject('Database') private db: Database
  ) {}
}

// 容器会自动解析整个依赖树：
// UserController -> UserService -> UserRepository -> Database
//                              -> EmailService
//                -> Logger
```

## 装饰器系统

### 1. @Injectable 装饰器

标记类为可注入的服务：

```typescript
@Injectable
class EmailService {
  send(email: Email) {
    // 发送邮件逻辑
  }
}

// 等价于手动注册
Reflect.defineMetadata('injectable', true, EmailService);
```

### 2. @Inject 装饰器

显式指定要注入的服务标识符：

```typescript
@Injectable
class UserService {
  constructor(
    @Inject('UserRepository') private userRepo: IUserRepository,
    @Inject('CACHE_TTL') private cacheTtl: number,
    @Inject('Logger') private logger: ILogger
  ) {}
}

// 支持多种类型的注入
container.bind('UserRepository', SqlUserRepository);
container.instance('CACHE_TTL', 3600);
container.bind('Logger', WinstonLogger);
```

### 3. @AutoInject 装饰器

用于属性注入（高级特性）：

```typescript
class UserController {
  @AutoInject('UserService')
  private userService: UserService;

  @AutoInject('Logger')
  private logger: Logger;

  async getUsers() {
    this.logger.log('Getting users');
    return await this.userService.findAll();
  }
}
```

## 生命周期管理

### 1. 瞬态（Transient）

每次解析都创建新实例：

```typescript
container.bind('Logger', FileLogger); // 默认瞬态

const logger1 = container.resolve('Logger');
const logger2 = container.resolve('Logger');
console.log(logger1 === logger2); // false
```

### 2. 单例（Singleton）

全局只有一个实例：

```typescript
container.singleton('Database', DatabaseConnection);

const db1 = container.resolve('Database');
const db2 = container.resolve('Database');
console.log(db1 === db2); // true
```

### 3. 作用域（Scoped）

在特定作用域内是单例（未来特性）：

```typescript
// 在请求作用域内是单例
container.scoped('UserContext', RequestUserContext);
```

## 服务提供者模式

服务提供者用于组织和封装相关服务的注册逻辑：

### 1. 基础服务提供者

```typescript
class DatabaseServiceProvider extends BaseServiceProvider {
  register(container: Container) {
    // 注册数据库相关服务
    container.singleton('Database', DatabaseConnection);
    container.bind('UserRepository', SqlUserRepository);
    container.bind('PostRepository', SqlPostRepository);
  }

  boot(container: Container) {
    // 启动时初始化
    const db = container.resolve('Database');
    db.connect();
  }
}
```

### 2. 条件注册

```typescript
class LoggingServiceProvider extends BaseServiceProvider {
  register(container: Container) {
    if (process.env.NODE_ENV === 'production') {
      container.bind('Logger', ProductionLogger);
    } else {
      container.bind('Logger', DevelopmentLogger);
    }
  }
}
```

## 实际代码演示

让我们看一个完整的电商系统示例：

```typescript
import 'reflect-metadata';
import { ServiceContainer, Injectable, Inject } from '@coffic/cosy-framework';

// 1. 定义接口
interface ILogger {
  log(message: string): void;
}

interface IPaymentGateway {
  charge(amount: number, cardToken: string): Promise<string>;
}

interface IEmailService {
  send(to: string, subject: string, body: string): Promise<void>;
}

interface IOrderRepository {
  save(order: Order): Promise<Order>;
  findById(id: string): Promise<Order | null>;
}

// 2. 实现服务
@Injectable
class ConsoleLogger implements ILogger {
  log(message: string) {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }
}

@Injectable
class StripePaymentGateway implements IPaymentGateway {
  async charge(amount: number, cardToken: string) {
    // 模拟 Stripe 支付
    console.log(`Charging $${amount} with token ${cardToken}`);
    return `charge_${Math.random().toString(36).substr(2, 9)}`;
  }
}

@Injectable
class SMTPEmailService implements IEmailService {
  constructor(
    @Inject('Logger') private logger: ILogger
  ) {}

  async send(to: string, subject: string, body: string) {
    this.logger.log(`Sending email to ${to}: ${subject}`);
    // 模拟发送邮件
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}

@Injectable
class SqlOrderRepository implements IOrderRepository {
  constructor(
    @Inject('Database') private db: any,
    @Inject('Logger') private logger: ILogger
  ) {}

  async save(order: Order) {
    this.logger.log(`Saving order ${order.id}`);
    // 模拟保存到数据库
    return order;
  }

  async findById(id: string) {
    this.logger.log(`Finding order ${id}`);
    // 模拟从数据库查询
    return new Order(id, 99.99, 'pending');
  }
}

// 3. 业务逻辑层
class Order {
  constructor(
    public id: string,
    public amount: number,
    public status: string
  ) {}
}

@Injectable
class OrderService {
  constructor(
    @Inject('OrderRepository') private orderRepo: IOrderRepository,
    @Inject('PaymentGateway') private paymentGateway: IPaymentGateway,
    @Inject('EmailService') private emailService: IEmailService,
    @Inject('Logger') private logger: ILogger
  ) {}

  async createOrder(amount: number, cardToken: string, customerEmail: string) {
    const orderId = `order_${Date.now()}`;
    this.logger.log(`Creating order ${orderId} for $${amount}`);

    try {
      // 1. 创建订单
      const order = new Order(orderId, amount, 'pending');
      await this.orderRepo.save(order);

      // 2. 处理支付
      const chargeId = await this.paymentGateway.charge(amount, cardToken);
      order.status = 'paid';
      await this.orderRepo.save(order);

      // 3. 发送确认邮件
      await this.emailService.send(
        customerEmail,
        'Order Confirmation',
        `Your order ${orderId} has been confirmed. Charge ID: ${chargeId}`
      );

      this.logger.log(`Order ${orderId} completed successfully`);
      return order;

    } catch (error) {
      this.logger.log(`Order ${orderId} failed: ${error.message}`);
      throw error;
    }
  }
}

// 4. 控制器层
@Injectable
class OrderController {
  constructor(
    @Inject('OrderService') private orderService: OrderService,
    @Inject('Logger') private logger: ILogger
  ) {}

  async createOrder(orderData: any) {
    this.logger.log('Processing new order request');
    
    const { amount, cardToken, customerEmail } = orderData;
    const order = await this.orderService.createOrder(amount, cardToken, customerEmail);
    
    return {
      success: true,
      orderId: order.id,
      status: order.status
    };
  }
}

// 5. 容器配置和使用
function setupContainer() {
  const container = new ServiceContainer();

  // 注册基础服务
  container.singleton('Logger', ConsoleLogger);
  container.singleton('Database', class MockDatabase {});

  // 注册业务服务
  container.bind('PaymentGateway', StripePaymentGateway);
  container.bind('EmailService', SMTPEmailService);
  container.bind('OrderRepository', SqlOrderRepository);
  container.bind('OrderService', OrderService);
  container.bind('OrderController', OrderController);

  return container;
}

// 6. 使用示例
async function demonstrateEcommerce() {
  const container = setupContainer();
  
  const orderController = container.resolve<OrderController>('OrderController');
  
  const result = await orderController.createOrder({
    amount: 99.99,
    cardToken: 'tok_test_card',
    customerEmail: 'customer@example.com'
  });
  
  console.log('Order result:', result);
}

// 运行演示
demonstrateEcommerce().catch(console.error);
```

## 高级特性

### 1. 工厂模式

```typescript
// 注册工厂函数
container.bind('ApiClient', class {
  constructor() {
    const config = container.resolve('Config');
    return new HttpClient(config.apiUrl, config.timeout);
  }
});
```

### 2. 装饰器组合

```typescript
@Injectable
@Singleton  // 自定义装饰器
class CacheService {
  // ...
}
```

### 3. 中间件支持

```typescript
container.addMiddleware('Logger', (next, target, propertyKey, args) => {
  console.log(`Calling ${target.constructor.name}.${propertyKey}`);
  return next();
});
```

## 常见问题解答

### Q1: 循环依赖如何处理？

**A:** 框架会检测循环依赖并抛出错误：
```typescript
// ❌ 循环依赖
class ServiceA {
  constructor(@Inject('ServiceB') private b: ServiceB) {}
}

class ServiceB {
  constructor(@Inject('ServiceA') private a: ServiceA) {}
}

// ✅ 解决方案：使用事件或重新设计架构
```

### Q2: 如何处理可选依赖？

**A:** 使用条件注入：
```typescript
@Injectable
class UserService {
  constructor(
    @Inject('Logger') private logger: ILogger,
    @Optional() @Inject('Cache') private cache?: ICache
  ) {}
}
```

### Q3: 性能如何？

**A:** 
- **首次解析**：需要构建依赖图，稍慢
- **后续解析**：单例服务直接返回缓存，极快
- **内存占用**：主要是元数据存储，通常很小

### Q4: 如何调试依赖注入问题？

**A:** 框架提供调试工具：
```typescript
// 查看容器状态
console.log(container.debug());

// 查看依赖图
console.log(container.getDependencyGraph('UserService'));
```

### Q5: 支持异步初始化吗？

**A:** 支持，通过服务提供者的 boot 方法：
```typescript
class AsyncServiceProvider extends BaseServiceProvider {
  async boot(container: Container) {
    const db = container.resolve('Database');
    await db.connect();
  }
}
```

## 与其他框架的对比

| 特性 | Cosy Framework | NestJS | Angular | Laravel |
|------|----------------|--------|---------|---------|
| 语言 | TypeScript | TypeScript | TypeScript | PHP |
| 装饰器 | ✅ | ✅ | ✅ | ✅ (Attributes) |
| 自动注入 | ✅ | ✅ | ✅ | ✅ |
| 生命周期 | ✅ | ✅ | ✅ | ✅ |
| 学习曲线 | 低 | 中 | 高 | 低 |

## 最佳实践

### 1. 服务设计原则

```typescript
// ✅ 单一职责原则
@Injectable
class EmailService {
  send(email: Email) { /* 只负责发送邮件 */ }
}

@Injectable
class EmailTemplateService {
  render(template: string, data: any) { /* 只负责渲染模板 */ }
}

// ❌ 违反单一职责
@Injectable
class EmailService {
  send(email: Email) { /* 发送邮件 */ }
  renderTemplate(template: string, data: any) { /* 渲染模板 */ }
  validateEmail(email: string) { /* 验证邮件 */ }
}
```

### 2. 接口优先

```typescript
// ✅ 定义接口
interface IUserRepository {
  findById(id: string): Promise<User | null>;
}

@Injectable
class SqlUserRepository implements IUserRepository {
  // 实现...
}

// 绑定到接口
container.bind<IUserRepository>('UserRepository', SqlUserRepository);
```

### 3. 合理使用单例

```typescript
// ✅ 适合单例：无状态、资源密集
container.singleton('Database', DatabaseConnection);
container.singleton('Cache', RedisCache);
container.singleton('Logger', Logger);

// ❌ 不适合单例：有状态、业务逻辑
container.bind('UserService', UserService);  // 瞬态
container.bind('OrderProcessor', OrderProcessor);  // 瞬态
```

## 总结

服务容器是现代 TypeScript 框架的核心，它通过依赖注入提供了：

✅ **松耦合架构** - 组件之间的依赖关系清晰明确  
✅ **高可测试性** - 轻松模拟和替换依赖  
✅ **优雅的语法** - 装饰器让代码简洁易读  
✅ **自动化管理** - 无需手动创建和连接对象  
✅ **生产就绪** - 高性能、稳定可靠  

掌握服务容器，你就掌握了现代框架开发的核心技能！🚀 