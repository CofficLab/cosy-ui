# TypeScript装饰器详解

装饰器（Decorator）是一种特殊类型的声明，它能够被附加到类声明、方法、访问符、属性或参数上。装饰器使用 `@expression` 这样的形式，其中 `expression` 必须计算为一个函数，该函数将在运行时被调用。

## 目录
1. [什么是装饰器](#什么是装饰器)
2. [装饰器的类型](#装饰器的类型)
3. [装饰器工厂](#装饰器工厂)
4. [装饰器组合](#装饰器组合)
5. [在依赖注入中的应用](#在依赖注入中的应用)

## 什么是装饰器

装饰器本质上是一个函数，它可以通过 `@` 符号添加到代码中的特定位置。这个函数会在代码运行时执行，可以用来修改类的行为。

### 基本语法

```typescript
function simpleDecorator(target: any) {
    // 装饰器逻辑
    console.log('装饰器被调用');
}

@simpleDecorator
class Example {
    // 类的内容
}
```

## 装饰器的类型

TypeScript支持以下几种装饰器：

### 1. 类装饰器

类装饰器应用于类构造函数，可以用来观察、修改或替换类定义。

```typescript
function classDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        newProperty = "新属性";
        hello = "override";
    }
}

@classDecorator
class Greeter {
    property = "属性";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}
```

### 2. 方法装饰器

方法装饰器应用于方法的属性描述符，可以用来观察、修改或替换方法定义。

```typescript
function methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // 保存原始方法
    const originalMethod = descriptor.value;

    // 修改方法的行为
    descriptor.value = function(...args: any[]) {
        console.log('方法调用前');
        const result = originalMethod.apply(this, args);
        console.log('方法调用后');
        return result;
    }
}

class Example {
    @methodDecorator
    greet() {
        console.log('Hello!');
    }
}
```

### 3. 属性装饰器

属性装饰器声明在一个属性声明之前。

```typescript
function propertyDecorator(target: any, propertyKey: string) {
    // 属性装饰器逻辑
}

class Example {
    @propertyDecorator
    name: string;
}
```

### 4. 参数装饰器

参数装饰器声明在一个参数声明之前。

```typescript
function parameterDecorator(target: any, propertyKey: string, parameterIndex: number) {
    // 参数装饰器逻辑
}

class Example {
    greet(@parameterDecorator name: string) {
        return "Hello, " + name;
    }
}
```

## 装饰器工厂

装饰器工厂是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。

```typescript
function decoratorFactory(value: string) {
    return function (target: any) {
        // 使用 value 参数进行一些操作
    }
}

@decoratorFactory("hello")
class Example {
}
```

## 装饰器组合

多个装饰器可以同时应用到一个声明上：

```typescript
function first() {
    console.log("first(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("first(): called");
    };
}

function second() {
    console.log("second(): factory evaluated");
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("second(): called");
    };
}

class Example {
    @first()
    @second()
    method() {}
}
```

装饰器的执行顺序：
1. 装饰器工厂从上到下依次执行
2. 装饰器函数从下到上依次执行

## 在依赖注入中的应用

在我们的服务容器中，装饰器主要用于标记可注入的服务和依赖关系。例如：

```typescript
@Injectable()
class UserService {
    constructor(
        @Inject() private userRepository: UserRepository,
        @Inject() private logger: Logger
    ) {}
}
```

这里的 `@Injectable()` 和 `@Inject()` 都是装饰器，它们告诉我们的依赖注入容器：

- `@Injectable()`：这个类可以被注入到其他类中
- `@Inject()`：这个参数需要被容器注入

### 实现简单的依赖注入装饰器

下面是一个简单的依赖注入装饰器实现示例：

```typescript
const Injectable = (): ClassDecorator => {
    return target => {
        // 在某处存储这个类，表明它是可注入的
        Reflect.defineMetadata('injectable', true, target);
    };
};

const Inject = (): ParameterDecorator => {
    return (target, propertyKey, parameterIndex) => {
        // 存储参数的注入信息
        const existingInjections = Reflect.getMetadata('injections', target) || [];
        existingInjections.push(parameterIndex);
        Reflect.defineMetadata('injections', existingInjections, target);
    };
};
```

## 注意事项

1. 装饰器是实验性特性，需要在 `tsconfig.json` 中启用：
```json
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
}
```

2. 装饰器执行时机是在类定义时，而不是实例化时
3. 装饰器不能用在声明文件（.d.ts）中
4. 装饰器不能用在任何外部上下文中（比如在declare的类中）

## 最佳实践

1. 保持装饰器的单一职责
2. 避免在装饰器中执行复杂的逻辑
3. 注意装饰器的执行顺序
4. 合理使用装饰器工厂来传递参数
5. 在文档中清晰说明装饰器的用途和使用方式

## 参考资料

- [TypeScript官方文档 - 装饰器](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [reflect-metadata](https://github.com/rbuckton/reflect-metadata) 
