# 步骤 01.5：reflect-metadata 详解

## 目标
深入理解 reflect-metadata 的工作原理和使用方法，为后续的装饰器实现打下基础。

## 概述
reflect-metadata 是一个用于在对象上添加和读取元数据的库，它是实现 TypeScript 装饰器和依赖注入的基础。

## 主要功能

### 1. 元数据操作

```typescript
// 定义元数据
Reflect.defineMetadata(metadataKey, metadataValue, target)
Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey)

// 获取元数据
const metadata = Reflect.getMetadata(metadataKey, target)
const metadata = Reflect.getMetadata(metadataKey, target, propertyKey)

// 检查元数据
const hasMetadata = Reflect.hasMetadata(metadataKey, target)
const hasMetadata = Reflect.hasMetadata(metadataKey, target, propertyKey)

// 删除元数据
Reflect.deleteMetadata(metadataKey, target)
Reflect.deleteMetadata(metadataKey, target, propertyKey)
```

### 2. 设计时类型

```typescript
// 获取参数类型
const paramTypes = Reflect.getMetadata('design:paramtypes', target)

// 获取返回类型
const returnType = Reflect.getMetadata('design:returntype', target, propertyKey)

// 获取属性类型
const propType = Reflect.getMetadata('design:type', target, propertyKey)
```

## 使用示例

### 1. 基础使用

```typescript
import 'reflect-metadata'

@Reflect.metadata('role', 'admin')
class User {
  @Reflect.metadata('required', true)
  name: string

  constructor(name: string) {
    this.name = name
  }
}

// 获取元数据
console.log(Reflect.getMetadata('role', User)) // 'admin'
console.log(Reflect.getMetadata('required', User.prototype, 'name')) // true
```

### 2. 装饰器中使用

```typescript
function Injectable() {
  return function(target: any) {
    Reflect.defineMetadata('injectable', true, target)
  }
}

function Inject(token?: any) {
  return function(target: any, propertyKey: string | symbol | undefined, parameterIndex?: number) {
    const type = Reflect.getMetadata('design:type', target, propertyKey!)
    Reflect.defineMetadata('inject', token || type, target, propertyKey!)
  }
}

@Injectable()
class UserService {
  @Inject()
  private database: Database
}
```

### 3. 依赖注入实现

```typescript
class Container {
  resolve<T>(target: new (...args: any[]) => T): T {
    // 获取构造函数参数类型
    const paramTypes = Reflect.getMetadata('design:paramtypes', target) || []
    
    // 解析依赖
    const dependencies = paramTypes.map((type: any) => this.resolve(type))
    
    // 创建实例
    return new target(...dependencies)
  }
}
```

## 注意事项

1. **启用装饰器**
   ```json
   {
     "compilerOptions": {
       "experimentalDecorators": true,
       "emitDecoratorMetadata": true
     }
   }
   ```

2. **导入顺序**
   - reflect-metadata 必须在使用装饰器之前导入
   - 建议在入口文件最开始导入

3. **元数据键**
   - 使用 Symbol 作为元数据键以避免冲突
   - 为相关的元数据键创建命名空间

4. **性能考虑**
   - 元数据会增加内存使用
   - 在生产环境可能需要清理不必要的元数据

## 最佳实践

1. **元数据键管理**
```typescript
const METADATA_KEY = {
  INJECTABLE: Symbol('injectable'),
  INJECT: Symbol('inject'),
  CONTROLLER: Symbol('controller'),
  ROUTE: Symbol('route')
}
```

2. **元数据工具函数**
```typescript
export function getInjectableMetadata(target: any): boolean {
  return Reflect.getMetadata(METADATA_KEY.INJECTABLE, target) || false
}

export function setInjectableMetadata(target: any): void {
  Reflect.defineMetadata(METADATA_KEY.INJECTABLE, true, target)
}
```

3. **类型安全**
```typescript
export interface TypeMetadata<T = any> {
  type: Constructor<T>
  optional?: boolean
  token?: symbol
}

export function getTypeMetadata<T>(target: any, propertyKey: string): TypeMetadata<T> {
  return Reflect.getMetadata(METADATA_KEY.TYPE, target, propertyKey)
}
```

## 完成标志
- [ ] 理解元数据的基本概念
- [ ] 掌握 reflect-metadata 的主要 API
- [ ] 能够在装饰器中正确使用元数据
- [ ] 理解依赖注入的实现原理

## 下一步
完成此步骤后，继续执行 [02-service-container.md](./02-service-container.md)。 
