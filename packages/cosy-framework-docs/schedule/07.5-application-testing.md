# 步骤 007.5：应用程序测试

## 目标
创建完整的测试套件，确保应用程序核心功能的正确性和可靠性。

## 任务清单
- [ ] 创建单元测试
- [ ] 创建集成测试
- [ ] 创建手动测试脚本
- [ ] 验证所有功能

## 执行步骤

### 1. 创建单元测试

**创建文件**: `tests/unit/application.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { Application, Bootstrap } from '../../src/core'
import { HttpContext, HttpMethod, HttpStatus } from '../../src/http'
import { Injectable } from '../../src/container'

describe('Application Core', () => {
  let app: Application

  beforeEach(() => {
    app = new Application()
  })

  afterEach(async () => {
    if (app.isRunning()) {
      await app.stop()
    }
  })

  describe('Application Lifecycle', () => {
    it('should boot application', async () => {
      await app.boot()
      expect(app.isRunning()).toBe(false) // Not started yet
    })

    it('should start and stop application', async () => {
      await app.boot()
      await app.start(3001)
      
      expect(app.isRunning()).toBe(true)
      expect(app.getPort()).toBe(3001)

      await app.stop()
      expect(app.isRunning()).toBe(false)
    })

    it('should not start if already running', async () => {
      await app.boot()
      await app.start(3002)

      await expect(app.start(3003)).rejects.toThrow('Application is already running')
      
      await app.stop()
    })
  })

  describe('Configuration', () => {
    it('should set and get configuration', () => {
      app.config('app.name', 'Test App')
      app.config('database.host', 'localhost')

      expect(app.config('app.name')).toBe('Test App')
      expect(app.config('database.host')).toBe('localhost')
    })

    it('should configure with callback', () => {
      app.configure((app) => {
        app.config('test.value', 'configured')
      })

      expect(app.config('test.value')).toBe('configured')
    })
  })

  describe('Service Container Integration', () => {
    it('should bind and resolve services', () => {
      @Injectable
      class TestService {
        getValue() {
          return 'test-value'
        }
      }

      app.bind('test-service', TestService)
      const service = app.resolve<TestService>('test-service')

      expect(service).toBeInstanceOf(TestService)
      expect(service.getValue()).toBe('test-value')
    })

    it('should register singleton services', () => {
      class SingletonService {
        private static count = 0
        public readonly id: number

        constructor() {
          this.id = ++SingletonService.count
        }
      }

      app.singleton('singleton', SingletonService)

      const instance1 = app.resolve<SingletonService>('singleton')
      const instance2 = app.resolve<SingletonService>('singleton')

      expect(instance1).toBe(instance2)
      expect(instance1.id).toBe(1)
    })
  })

  describe('Routing Integration', () => {
    it('should register and handle routes', async () => {
      app.get('/test', () => 'Hello World')
      app.post('/users', () => ({ id: 1, name: 'John' }))

      const getRequest = HttpContext.create({ method: 'GET', url: '/test' }).request
      const postRequest = HttpContext.create({ method: 'POST', url: '/users' }).request

      const getResponse = await app.handle(getRequest)
      const postResponse = await app.handle(postRequest)

      expect(getResponse.getStatus()).toBe(HttpStatus.OK)
      expect(getResponse.getContent()).toBe('Hello World')

      expect(postResponse.getStatus()).toBe(HttpStatus.OK)
      expect(JSON.parse(postResponse.getContent())).toEqual({ id: 1, name: 'John' })
    })

    it('should handle route parameters', async () => {
      app.get('/users/{id}', (context) => {
        return { userId: context.request.params.id }
      })

      const request = HttpContext.create({ method: 'GET', url: '/users/123' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.OK)
      expect(JSON.parse(response.getContent())).toEqual({ userId: '123' })
    })

    it('should return 404 for unknown routes', async () => {
      const request = HttpContext.create({ method: 'GET', url: '/unknown' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.NOT_FOUND)
      expect(JSON.parse(response.getContent())).toMatchObject({
        error: 'Route not found',
        path: '/unknown',
        method: 'GET'
      })
    })

    it('should support route groups', async () => {
      app.group('/api', (router) => {
        router.get('/status', () => ({ status: 'ok' }))
        router.get('/health', () => ({ health: 'good' }))
      })

      const statusRequest = HttpContext.create({ method: 'GET', url: '/api/status' }).request
      const healthRequest = HttpContext.create({ method: 'GET', url: '/api/health' }).request

      const statusResponse = await app.handle(statusRequest)
      const healthResponse = await app.handle(healthRequest)

      expect(statusResponse.getStatus()).toBe(HttpStatus.OK)
      expect(healthResponse.getStatus()).toBe(HttpStatus.OK)
    })
  })

  describe('Middleware Integration', () => {
    it('should execute global middleware', async () => {
      const order: number[] = []

      app.use(async (context, next) => {
        order.push(1)
        await next()
        order.push(4)
      })

      app.use(async (context, next) => {
        order.push(2)
        await next()
        order.push(3)
      })

      app.get('/test', () => {
        order.push(5)
        return 'success'
      })

      const request = HttpContext.create({ method: 'GET', url: '/test' }).request
      await app.handle(request)

      expect(order).toEqual([1, 2, 5, 3, 4])
    })

    it('should handle middleware errors', async () => {
      app.use(async () => {
        throw new Error('Middleware error')
      })

      app.get('/test', () => 'success')

      const request = HttpContext.create({ method: 'GET', url: '/test' }).request
      const response = await app.handle(request)

      expect(response.getStatus()).toBe(HttpStatus.INTERNAL_SERVER_ERROR)
      expect(JSON.parse(response.getContent())).toMatchObject({
        error: 'Middleware error'
      })
    })
  })

  describe('Application Factory', () => {
    it('should create application with static method', () => {
      const staticApp = Application.create({
        name: 'Static App',
        port: 4000
      })

      expect(staticApp.config('app.name')).toBe('Static App')
      expect(staticApp.config('app.port')).toBe(4000)
    })
  })

  describe('Bootstrap', () => {
    it('should bootstrap application', async () => {
      const bootstrap = Bootstrap.create({
        config: {
          name: 'Bootstrap App',
          port: 5000
        }
      })

      const bootstrappedApp = await bootstrap.start()
      
      expect(bootstrappedApp.isRunning()).toBe(true)
      expect(bootstrappedApp.config('app.name')).toBe('Bootstrap App')
      
      await bootstrappedApp.stop()
    })
  })
})
```

### 2. 创建手动测试脚本

**创建文件**: `tests/manual-application-test.ts`

```typescript
import { 
  Application, 
  Bootstrap,
  createWebApp,
  gracefulShutdown,
  App,
  Controller,
  Get,
  Post
} from '../src/core'
import { Injectable, Inject } from '../src/container'
import { cors, logger } from '../src/middleware'
import { Environment } from '../src/config'

console.log('=== 应用程序核心测试 ===')

// 1. 基础应用创建和配置
console.log('\n1. 基础应用创建')

const app = Application.create({
  name: 'Cosy Framework Test App',
  debug: true,
  port: 3000
})

console.log('应用名称:', app.config('app.name'))
console.log('调试模式:', app.config('app.debug'))
console.log('端口:', app.config('app.port'))

// 2. 服务注册测试
console.log('\n2. 服务注册测试')

@Injectable
class DatabaseService {
  connect() {
    return 'Database connected'
  }
}

@Injectable
class UserService {
  constructor(@Inject('DatabaseService') private db: DatabaseService) {}

  getUsers() {
    return [
      { id: 1, name: 'John Doe' },
      { id: 2, name: 'Jane Smith' }
    ]
  }

  getDatabaseStatus() {
    return this.db.connect()
  }
}

app.bind('DatabaseService', DatabaseService)
app.bind('UserService', UserService)

const userService = app.resolve<UserService>('UserService')
console.log('用户服务测试:', userService.getDatabaseStatus())
console.log('用户列表:', userService.getUsers())

// 3. 中间件测试
console.log('\n3. 中间件测试')

app.use(logger())
app.use(cors({ origin: '*' }))

app.use(async (context, next) => {
  console.log(`请求: ${context.request.method} ${context.request.path}`)
  const start = Date.now()
  await next()
  const duration = Date.now() - start
  console.log(`响应时间: ${duration}ms`)
})

// 4. 路由测试
console.log('\n4. 路由注册')

app.get('/', () => {
  return {
    message: 'Welcome to Cosy Framework!',
    version: '0.1.0',
    timestamp: new Date().toISOString()
  }
})

app.get('/users', (context) => {
  const userService = app.resolve<UserService>('UserService')
  return {
    users: userService.getUsers(),
    total: 2
  }
})

app.get('/users/{id}', (context) => {
  const id = parseInt(context.request.params.id)
  const users = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
  ]
  
  const user = users.find(u => u.id === id)
  if (!user) {
    context.response.status(404)
    return { error: 'User not found' }
  }
  
  return { user }
})

app.post('/users', (context) => {
  const { name, email } = context.request.body
  return {
    id: 3,
    name,
    email,
    created_at: new Date().toISOString()
  }
})

// API 路由组
app.group('/api/v1', (router) => {
  router.get('/status', () => ({
    status: 'ok',
    timestamp: Date.now(),
    environment: Environment.getCurrent()
  }))

  router.get('/health', () => ({
    health: 'good',
    uptime: process.uptime(),
    memory: process.memoryUsage()
  }))
})

console.log('注册的路由数量:', app.getRouter().getRoutes().length)

// 5. 控制器装饰器测试（演示）
console.log('\n5. 控制器装饰器演示')

@Controller('/api/posts')
class PostController {
  @Get('/')
  index() {
    return {
      posts: [
        { id: 1, title: 'First Post' },
        { id: 2, title: 'Second Post' }
      ]
    }
  }

  @Get('/{id}')
  show() {
    return { post: { id: 1, title: 'Post Detail' } }
  }

  @Post('/')
  create() {
    return { message: 'Post created', id: 3 }
  }
}

console.log('控制器装饰器已定义（需要手动注册到路由）')

// 6. 应用启动测试
console.log('\n6. 应用启动测试')

async function testApplication() {
  try {
    console.log('正在启动应用...')
    await app.boot()
    await app.start(3000)

    console.log('✓ 应用启动成功')
    console.log('应用状态:', app.isRunning() ? '运行中' : '已停止')
    console.log('监听端口:', app.getPort())

    // 模拟请求处理测试
    console.log('\n7. 请求处理测试')
    
    const { HttpContext } = await import('../src/http')
    
    const testRequests = [
      { method: 'GET', url: '/' },
      { method: 'GET', url: '/users' },
      { method: 'GET', url: '/users/1' },
      { method: 'GET', url: '/api/v1/status' },
      { method: 'GET', url: '/nonexistent' }
    ]

    for (const req of testRequests) {
      const context = HttpContext.create(req)
      const response = await app.handle(context.request)
      
      console.log(`${req.method} ${req.url} → ${response.getStatus()}`)
      if (response.getContent()) {
        const content = response.getContent()
        if (content.length < 200) {
          console.log(`  响应: ${content}`)
        } else {
          console.log(`  响应: ${content.substring(0, 100)}...`)
        }
      }
    }

    // 停止应用
    console.log('\n正在停止应用...')
    await app.stop()
    console.log('✓ 应用已停止')

  } catch (error) {
    console.error('应用测试失败:', error)
  }
}

// 8. Bootstrap 测试
console.log('\n8. Bootstrap 测试')

async function testBootstrap() {
  try {
    console.log('使用 Bootstrap 启动应用...')
    
    const bootstrap = Bootstrap.create({
      config: {
        name: 'Bootstrap Test App',
        port: 3001,
        debug: true
      },
      hooks: {
        beforeStart: () => console.log('🔄 准备启动...'),
        afterStart: () => console.log('✅ 启动完成!'),
        beforeStop: () => console.log('🔄 准备停止...'),
        afterStop: () => console.log('✅ 停止完成!')
      }
    })

    const bootstrappedApp = await bootstrap.start()
    console.log('Bootstrap 应用运行状态:', bootstrappedApp.isRunning())
    
    // 稍等一下然后停止
    setTimeout(async () => {
      await bootstrappedApp.stop()
    }, 1000)

  } catch (error) {
    console.error('Bootstrap 测试失败:', error)
  }
}

// 运行测试
testApplication().then(() => {
  return testBootstrap()
}).then(() => {
  console.log('\n=== 应用程序核心测试完成 ===')
}).catch(error => {
  console.error('测试过程中出现错误:', error)
})
```

### 3. 运行测试

```bash
# 运行单元测试
npm test tests/unit/application.test.ts

# 运行手动测试
npx tsx tests/manual-application-test.ts
```

## 测试覆盖范围

1. **生命周期测试**
   - 启动和停止
   - 生命周期钩子
   - 错误处理

2. **配置测试**
   - 配置读写
   - 环境配置
   - 配置合并

3. **服务容器测试**
   - 服务绑定和解析
   - 单例服务
   - 依赖注入

4. **路由测试**
   - 路由注册
   - 路由参数
   - 路由组
   - 404 处理

5. **中间件测试**
   - 中间件执行顺序
   - 错误处理
   - 全局中间件

6. **Bootstrap 测试**
   - 配置加载
   - 服务提供者
   - 生命周期钩子

## 完成标志
- [ ] 所有单元测试通过
- [ ] 手动测试脚本运行成功
- [ ] 测试覆盖率达到目标
- [ ] 所有核心功能都有测试
- [ ] 错误处理测试完整
- [ ] TypeScript 类型检查无错误

## 下一步
完成此步骤后，继续执行 `step-008-basic-example.md`。 
