# 步骤 02.5：服务容器测试

## 目标
创建完整的测试套件，确保服务容器功能的正确性和可靠性。

## 任务清单
- [ ] 创建单元测试
- [ ] 创建集成测试
- [ ] 创建手动测试脚本
- [ ] 验证所有功能

## 执行步骤

### 1. 创建单元测试

**创建文件**: `tests/unit/container.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { Container } from '../../src/container'
import { Injectable, Inject } from '../../src/container/decorators'
import { ServiceProvider } from '../../src/container/provider'

describe('Container', () => {
  let container: Container

  beforeEach(() => {
    container = new Container()
  })

  describe('Service Registration', () => {
    it('should bind and resolve transient services', () => {
      class TestService {
        getValue() {
          return 'test'
        }
      }

      container.bind('test', TestService)
      
      const instance1 = container.resolve<TestService>('test')
      const instance2 = container.resolve<TestService>('test')
      
      expect(instance1).toBeInstanceOf(TestService)
      expect(instance2).toBeInstanceOf(TestService)
      expect(instance1).not.toBe(instance2)
    })

    it('should register singleton services', () => {
      class SingletonService {
        private static count = 0
        public readonly id: number

        constructor() {
          this.id = ++SingletonService.count
        }
      }

      container.singleton('singleton', SingletonService)

      const instance1 = container.resolve<SingletonService>('singleton')
      const instance2 = container.resolve<SingletonService>('singleton')

      expect(instance1).toBe(instance2)
      expect(instance1.id).toBe(1)
    })
  })

  describe('Dependency Injection', () => {
    it('should inject dependencies', () => {
      @Injectable()
      class DatabaseService {
        getName() {
          return 'Database'
        }
      }

      @Injectable()
      class UserService {
        constructor(@Inject() private db: DatabaseService) {}

        getDbName() {
          return this.db.getName()
        }
      }

      container.singleton('db', DatabaseService)
      container.singleton('users', UserService)

      const userService = container.resolve<UserService>('users')
      expect(userService.getDbName()).toBe('Database')
    })

    it('should handle optional dependencies', () => {
      @Injectable()
      class ConfigService {
        constructor(@Inject('logger', true) private logger?: any) {}

        hasLogger() {
          return !!this.logger
        }
      }

      container.singleton('config', ConfigService)
      const config = container.resolve<ConfigService>('config')
      
      expect(config.hasLogger()).toBe(false)
    })
  })

  describe('Service Provider', () => {
    it('should register services via provider', async () => {
      class TestProvider extends ServiceProvider {
        protected registerServices(): void {
          this.container.singleton('test', class TestService {})
        }

        async boot(): Promise<void> {
          // 启动逻辑
        }
      }

      container.register(new TestProvider())
      await container.boot()

      expect(container.has('test')).toBe(true)
    })

    it('should handle provider lifecycle', async () => {
      const events: string[] = []

      class LifecycleProvider extends ServiceProvider {
        protected registerServices(): void {
          events.push('register')
        }

        async boot(): Promise<void> {
          events.push('boot')
        }

        async shutdown(): Promise<void> {
          events.push('shutdown')
        }
      }

      container.register(new LifecycleProvider())
      await container.boot()
      await container.shutdown()

      expect(events).toEqual(['register', 'boot', 'shutdown'])
    })
  })

  describe('Error Handling', () => {
    it('should throw on missing service', () => {
      expect(() => container.resolve('missing')).toThrow('Service not found')
    })

    it('should detect circular dependencies', () => {
      @Injectable()
      class ServiceA {
        constructor(@Inject() private b: any) {}
      }

      @Injectable()
      class ServiceB {
        constructor(@Inject() private a: any) {}
      }

      container.singleton('a', ServiceA)
      container.singleton('b', ServiceB)

      expect(() => container.resolve('a')).toThrow('Circular dependency')
    })
  })
})
```

### 2. 创建手动测试脚本

**创建文件**: `tests/manual-container-test.ts`

```typescript
import { Container } from '../src/container'
import { Injectable, Inject } from '../src/container/decorators'
import { ServiceProvider } from '../src/container/provider'

console.log('=== 服务容器测试 ===')

// 1. 基础服务注册和解析
console.log('\n1. 基础服务测试')

@Injectable()
class LoggerService {
  log(message: string) {
    console.log(`[Logger] ${message}`)
  }
}

@Injectable()
class ConfigService {
  get(key: string) {
    return `Config value for ${key}`
  }
}

@Injectable()
class UserService {
  constructor(
    @Inject() private logger: LoggerService,
    @Inject() private config: ConfigService
  ) {}

  getUser(id: number) {
    this.logger.log(`Getting user ${id}`)
    const dbUrl = this.config.get('database.url')
    return { id, name: 'John Doe', dbUrl }
  }
}

const container = new Container()

// 注册服务
container.singleton('logger', LoggerService)
container.singleton('config', ConfigService)
container.singleton('users', UserService)

// 解析和使用服务
const userService = container.resolve<UserService>('users')
console.log('用户信息:', userService.getUser(1))

// 2. 服务提供者测试
console.log('\n2. 服务提供者测试')

class AppServiceProvider extends ServiceProvider {
  protected registerServices(): void {
    this.container.singleton('app.name', class {
      getName() { return 'Test App' }
    })
  }

  async boot(): Promise<void> {
    console.log('Provider booting...')
  }

  async shutdown(): Promise<void> {
    console.log('Provider shutting down...')
  }
}

// 注册提供者
container.register(new AppServiceProvider())

// 3. 生命周期测试
console.log('\n3. 生命周期测试')

async function testLifecycle() {
  console.log('启动容器...')
  await container.boot()

  console.log('使用服务...')
  const appName = container.resolve('app.name')
  console.log('应用名称:', appName.getName())

  console.log('关闭容器...')
  await container.shutdown()
}

// 4. 错误处理测试
console.log('\n4. 错误处理测试')

function testErrors() {
  try {
    container.resolve('non-existent')
  } catch (error) {
    console.log('预期的错误:', error.message)
  }

  try {
    @Injectable()
    class A {
      constructor(@Inject() private b: B) {}
    }

    @Injectable()
    class B {
      constructor(@Inject() private a: A) {}
    }

    container.singleton('a', A)
    container.singleton('b', B)
    container.resolve('a')
  } catch (error) {
    console.log('循环依赖错误:', error.message)
  }
}

// 运行测试
testLifecycle().then(() => {
  testErrors()
  console.log('\n=== 服务容器测试完成 ===')
}).catch(error => {
  console.error('测试过程中出现错误:', error)
})
```

### 3. 运行测试

```bash
# 运行单元测试
npm test tests/unit/container.test.ts

# 运行手动测试
npx tsx tests/manual-container-test.ts
```

## 测试覆盖范围

1. **服务注册测试**
   - 瞬态服务注册
   - 单例服务注册
   - 工厂函数注册

2. **依赖注入测试**
   - 构造函数注入
   - 属性注入
   - 可选依赖
   - 循环依赖检测

3. **服务提供者测试**
   - 服务注册
   - 生命周期钩子
   - 错误处理

4. **装饰器测试**
   - @Injectable
   - @Inject
   - 元数据处理

## 完成标志
- [ ] 所有单元测试通过
- [ ] 手动测试脚本运行成功
- [ ] 测试覆盖率达到目标
- [ ] 所有核心功能都有测试
- [ ] 错误处理测试完整
- [ ] TypeScript 类型检查无错误

## 下一步
完成此步骤后，继续执行 `step-003-routing.md`。 
