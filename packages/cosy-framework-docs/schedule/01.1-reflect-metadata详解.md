# 附件 01.1：reflect-metadata 详解

> 本文档是步骤 01 的补充材料，深入讲解 `reflect-metadata` 的核心概念和在 Cosy Framework 中的重要作用。
> 
> **文件命名规则**: 
> - 主步骤：`01-xxx.md`、`02-xxx.md`、...
> - 附件文档：`01.1-xxx.md`、`01.2-xxx.md`、`02.1-xxx.md`、...

## 📚 目录
- [什么是 reflect-metadata](#什么是-reflect-metadata)
- [为什么需要它](#为什么需要它)
- [核心 API 介绍](#核心-api-介绍)
- [在依赖注入中的应用](#在依赖注入中的应用)
- [装饰器与元数据的结合](#装饰器与元数据的结合)
- [实际代码演示](#实际代码演示)
- [常见问题解答](#常见问题解答)

## 🎯 可运行演示

我们在 `examples/` 目录中提供了两个演示文件：

1. **[reflect-metadata-simple.ts](../examples/reflect-metadata-simple.ts)** - 简化版演示，专注于核心概念
2. **[reflect-metadata-demo.ts](../examples/reflect-metadata-demo.ts)** - 完整版演示，包含装饰器语法

运行演示：
```bash
cd packages/cosy-framework-docs
npx tsx examples/reflect-metadata-simple.ts
```

## 什么是 reflect-metadata

`reflect-metadata` 是一个 **JavaScript/TypeScript 反射库**，它扩展了原生的 `Reflect` API，提供了在运行时存储和检索元数据的能力。

### 核心概念

```typescript
// 元数据就是"数据的数据"
// 比如：类型信息、装饰器配置、依赖关系等

class User {
  @Column({ type: 'varchar', length: 255 })  // 这是元数据
  name: string;                               // 这是数据
}
```

## 为什么需要它

### 1. TypeScript 类型擦除问题

TypeScript 编译后，所有类型信息都会丢失：

```typescript
// TypeScript 源码
class UserService {
  constructor(private database: DatabaseService) {}
}

// 编译后的 JavaScript
class UserService {
  constructor(database) {  // 类型信息丢失！
    this.database = database;
  }
}
```

### 2. 依赖注入需要类型信息

IoC 容器需要知道：
- 这个类需要哪些依赖？
- 每个依赖的类型是什么？
- 如何创建和注入这些依赖？

```typescript
// 容器需要回答这些问题：
class UserService {
  constructor(database: ???) {}  // 需要什么类型？
  //          ^^^^^^^^ 
  //          reflect-metadata 提供答案
}
```

## 核心 API 介绍

### 1. 基础元数据操作

```typescript
import 'reflect-metadata';

// 定义元数据
Reflect.defineMetadata(key, value, target, propertyKey?);

// 获取元数据
Reflect.getMetadata(key, target, propertyKey?);

// 检查是否存在
Reflect.hasMetadata(key, target, propertyKey?);

// 删除元数据
Reflect.deleteMetadata(key, target, propertyKey?);
```

### 2. 自动生成的设计时元数据

当启用 `emitDecoratorMetadata: true` 时，TypeScript 会自动生成：

```typescript
// 自动生成的元数据键
'design:type'        // 属性类型
'design:paramtypes'  // 构造函数参数类型
'design:returntype'  // 方法返回类型
```

## 在依赖注入中的应用

### 1. 自动依赖发现

```typescript
class DatabaseService {
  connect() { console.log('Connected to database'); }
}

class UserService {
  // TypeScript 自动生成: 
  // Reflect.defineMetadata('design:paramtypes', [DatabaseService], UserService);
  constructor(private db: DatabaseService) {}
}

// 容器可以自动发现依赖
const paramTypes = Reflect.getMetadata('design:paramtypes', UserService);
console.log(paramTypes); // [DatabaseService]
```

### 2. 简单的 IoC 容器实现

```typescript
class SimpleContainer {
  private bindings = new Map();
  
  bind<T>(token: string, implementation: new (...args: any[]) => T) {
    this.bindings.set(token, implementation);
  }
  
  resolve<T>(token: string): T {
    const Implementation = this.bindings.get(token);
    
    // 获取构造函数参数类型（关键步骤！）
    const paramTypes = Reflect.getMetadata('design:paramtypes', Implementation) || [];
    
    // 递归解析依赖
    const dependencies = paramTypes.map(ParamType => {
      const dependencyToken = ParamType.name; // 简化：使用类名作为 token
      return this.resolve(dependencyToken);
    });
    
    // 创建实例并注入依赖
    return new Implementation(...dependencies);
  }
}
```

## 装饰器与元数据的结合

### 1. 创建装饰器

```typescript
// Injectable 装饰器
function Injectable(target: any) {
  // 标记为可注入
  Reflect.defineMetadata('injectable', true, target);
  
  // 保存依赖信息
  const paramTypes = Reflect.getMetadata('design:paramtypes', target) || [];
  Reflect.defineMetadata('dependencies', paramTypes, target);
}

// Inject 装饰器
function Inject(token: string) {
  return function (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {
    const existingTokens = Reflect.getMetadata('inject-tokens', target) || [];
    existingTokens[parameterIndex] = token;
    Reflect.defineMetadata('inject-tokens', existingTokens, target);
  };
}
```

### 2. 使用装饰器

```typescript
@Injectable
class UserService {
  constructor(
    @Inject('DatabaseService') private db: DatabaseService,
    @Inject('CacheService') private cache: CacheService
  ) {}
}

// 元数据被自动保存
const isInjectable = Reflect.getMetadata('injectable', UserService); // true
const dependencies = Reflect.getMetadata('dependencies', UserService); // [DatabaseService, CacheService]
const injectTokens = Reflect.getMetadata('inject-tokens', UserService); // ['DatabaseService', 'CacheService']
```

## 实际代码演示

让我们运行一个完整的示例：

```typescript
import 'reflect-metadata';

// 1. 定义服务
class DatabaseService {
  connect() {
    return 'Database connected';
  }
}

class LoggerService {
  log(message: string) {
    console.log(`[LOG] ${message}`);
  }
}

class UserService {
  constructor(
    private db: DatabaseService,
    private logger: LoggerService
  ) {}
  
  getUsers() {
    const result = this.db.connect();
    this.logger.log('Getting users');
    return ['user1', 'user2'];
  }
}

// 2. 高级容器实现
class Container {
  private bindings = new Map();
  private instances = new Map();
  
  bind<T>(token: string, implementation: new (...args: any[]) => T, singleton: boolean = false) {
    this.bindings.set(token, { implementation, singleton });
  }
  
  resolve<T>(token: string): T {
    // 检查单例缓存
    if (this.instances.has(token)) {
      return this.instances.get(token);
    }
    
    const binding = this.bindings.get(token);
    if (!binding) {
      throw new Error(`No binding found for ${token}`);
    }
    
    const { implementation: Implementation, singleton } = binding;
    
    // 获取依赖类型
    const paramTypes = Reflect.getMetadata('design:paramtypes', Implementation) || [];
    
    // 解析依赖
    const dependencies = paramTypes.map((ParamType: any) => {
      return this.resolve(ParamType.name);
    });
    
    // 创建实例
    const instance = new Implementation(...dependencies);
    
    // 缓存单例
    if (singleton) {
      this.instances.set(token, instance);
    }
    
    return instance;
  }
}

// 3. 使用示例
const container = new Container();

// 注册服务
container.bind('DatabaseService', DatabaseService, true);  // 单例
container.bind('LoggerService', LoggerService, true);      // 单例
container.bind('UserService', UserService);               // 每次创建新实例

// 解析服务
const userService = container.resolve<UserService>('UserService');
console.log(userService.getUsers());

// 验证单例
const userService2 = container.resolve<UserService>('UserService');
const db1 = container.resolve<DatabaseService>('DatabaseService');
const db2 = container.resolve<DatabaseService>('DatabaseService');

console.log('不同的 UserService 实例:', userService !== userService2);  // true
console.log('相同的 Database 实例:', db1 === db2);                     // true
```

## 在 Cosy Framework 中的应用预览

在我们正在开发的框架中，`reflect-metadata` 将支持这样的语法：

```typescript
// 控制器定义
@Controller('/api/users')
export class UserController {
  constructor(
    @Inject('UserService') private userService: UserService,
    @Inject('Logger') private logger: Logger
  ) {}
  
  @Get('/')
  @Middleware(authMiddleware)
  async index() {
    this.logger.log('Getting all users');
    return await this.userService.findAll();
  }
  
  @Post('/')
  @Validate(CreateUserDto)
  async create(@Body() userData: CreateUserDto) {
    return await this.userService.create(userData);
  }
}

// 服务定义
@Injectable
export class UserService {
  constructor(
    @Inject('UserRepository') private userRepo: UserRepository,
    @Inject('EventDispatcher') private events: EventDispatcher
  ) {}
  
  async create(data: CreateUserDto) {
    const user = await this.userRepo.create(data);
    await this.events.dispatch('user.created', user);
    return user;
  }
}
```

## 常见问题解答

### Q1: 为什么必须在文件最前面导入？

**A:** 因为 `reflect-metadata` 是一个 polyfill，它扩展了全局的 `Reflect` 对象。TypeScript 编译的装饰器代码会立即使用这些 API，所以必须在任何装饰器代码执行前加载。

### Q2: 如果忘记导入会发生什么？

**A:** 会出现运行时错误：
```
TypeError: Reflect.getMetadata is not a function
```

### Q3: 它对性能有影响吗？

**A:** 
- **编译时**：会增加一些编译后的代码体积
- **运行时**：元数据查询是快速的，影响微乎其微
- **内存**：会存储一些额外的元数据，但通常很小

### Q4: 可以在生产环境使用吗？

**A:** 是的，许多知名框架都在生产环境使用：
- Angular
- NestJS  
- TypeORM
- InversifyJS

### Q5: 有替代方案吗？

**A:** 
- **手动注册**：手动指定依赖关系（失去自动化）
- **代码生成**：编译时生成依赖信息（增加复杂性）
- **运行时分析**：分析源码字符串（性能差，不可靠）

## 总结

`reflect-metadata` 是现代 TypeScript 框架的核心基础设施：

✅ **类型保留**：在运行时保留 TypeScript 类型信息  
✅ **装饰器支持**：为装饰器提供数据存储能力  
✅ **自动注入**：实现自动依赖发现和注入  
✅ **开发体验**：提供类似 Laravel 的优雅语法  
✅ **生产就绪**：被广泛使用，稳定可靠  

理解了 `reflect-metadata`，你就理解了现代 TypeScript 框架的"魔法"原理！ 
